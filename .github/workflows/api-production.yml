name: CI/CD Production - API
on:
  push:
    branches:
      - main
      - chore/test-ci # temporal
    paths:
      - "apps/backend/api/**"
      - "packages/messaging-utils/messaging-utils-py/**"
  workflow_dispatch:
    inputs:
      promote_from_staging:
        description: "Promote a staging version to production (e.g., 1.05-rc). Leave empty to create new version."
        required: false
        type: string
      bump_type:
        description: "Version bump type (only used if not promoting)"
        required: false
        type: choice
        options:
          - auto
          - minor
          - major
        default: "auto"
      custom_version:
        description: "Custom version (optional, e.g., 2.00)"
        required: false
        type: string
      dry_run:
        description: "Dry run (calculate version but don't create tag)"
        required: false
        type: boolean
        default: true

permissions:
  contents: write # to create tags

jobs:
  docker-build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine production version
        id: version
        shell: bash
        run: |
          if [ -n "${{ inputs.promote_from_staging }}" ]; then
            # Promote from staging: remove the -rc suffix
            STAGING_VERSION="${{ inputs.promote_from_staging }}"
            PROD_VERSION="${STAGING_VERSION%-rc}"

            # Verify that the staging tag exists
            if ! git tag -l "$STAGING_VERSION" | grep -q "$STAGING_VERSION"; then
              echo "Error: Staging tag $STAGING_VERSION does not exist"
              echo "Available staging tags:"
              git tag -l "*.??-rc" | tail -5
              exit 1
            fi

            # Check if production tag already exists
            if git tag -l "$PROD_VERSION" | grep -q "$PROD_VERSION"; then
              echo "Warning: Production tag $PROD_VERSION already exists"
              exit 1
            fi

            echo "Promoting $STAGING_VERSION â†’ $PROD_VERSION"
            echo "version=$PROD_VERSION" >> $GITHUB_OUTPUT
            echo "is_promotion=true" >> $GITHUB_OUTPUT
            echo "staging_version=$STAGING_VERSION" >> $GITHUB_OUTPUT
          else
            echo "is_promotion=false" >> $GITHUB_OUTPUT
          fi

      - name: Create version tag (promotion)
        if: steps.version.outputs.is_promotion == 'true' && inputs.dry_run != true
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          STAGING_VERSION="${{ steps.version.outputs.staging_version }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create production tag pointing to the same commit as staging tag
          STAGING_COMMIT=$(git rev-list -n 1 "$STAGING_VERSION")
          git tag -a "$VERSION" "$STAGING_COMMIT" -m "Production release $VERSION - Promoted from $STAGING_VERSION"
          git push origin "$VERSION"

          echo "Production tag $VERSION created (promoted from $STAGING_VERSION)"
          echo "Commit: $STAGING_COMMIT"

      - name: Create version tag (new version)
        if: steps.version.outputs.is_promotion != 'true'
        id: new_version
        uses: ./.github/actions/create-version-tag
        with:
          bump_type: ${{ inputs.bump_type || 'auto' }}
          custom_version: ${{ inputs.custom_version || '' }}
          suffix: ""
          dry_run: ${{ inputs.dry_run || 'false' }}

      - name: Set final version
        id: final_version
        shell: bash
        run: |
          if [ "${{ steps.version.outputs.is_promotion }}" == "true" ]; then
            echo "version=${{ steps.version.outputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "version=${{ steps.new_version.outputs.version }}" >> $GITHUB_OUTPUT
          fi

      - name: Build Docker Image
        uses: ./.github/actions/build-docker-image
        with:
          service_name: "api"
          verify_image: "true"
          push_image: "true"
          registry_username: ${{ secrets.DOCKERHUB_USERNAME }}
          registry_password: ${{ secrets.DOCKERHUB_TOKEN }}
          image_name: "etl-api"
          image_tag: ${{ steps.final_version.outputs.version }}
    
  # When docker stack is ready, there should be another job here to
  # update docker-stack files and deploy to production environment
