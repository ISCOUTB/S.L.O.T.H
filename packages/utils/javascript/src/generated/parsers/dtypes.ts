/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 6.32.0
 * source: parsers/dtypes.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace dtypes {
    export enum AstType {
        AST_UNKNOWN = 0,
        AST_BINARY_EXPRESSION = 1,
        AST_CELL_RANGE = 2,
        AST_FUNCTION = 3,
        AST_CELL = 4,
        AST_NUMBER = 5,
        AST_LOGICAL = 6,
        AST_TEXT = 7,
        AST_UNARY_EXPRESSION = 8
    }
    export enum RefType {
        REF_UNKNOWN = 0,
        REF_RELATIVE = 1,
        REF_ABSOLUTE = 2,
        REF_MIXED = 3
    }
    export class AST extends pb_1.Message {
        #one_of_decls: number[][] = [[10, 11, 12], [2], [3], [4], [6], [7], [8], [9]];
        constructor(data?: any[] | ({
            type?: AstType;
            arguments?: AST[];
        } & (({
            number_value?: number;
            text_value?: never;
            logical_value?: never;
        } | {
            number_value?: never;
            text_value?: string;
            logical_value?: never;
        } | {
            number_value?: never;
            text_value?: never;
            logical_value?: boolean;
        }) | ({
            operator?: string;
        }) | ({
            left?: AST;
        }) | ({
            right?: AST;
        }) | ({
            name?: string;
        }) | ({
            refType?: RefType;
        }) | ({
            key?: string;
        }) | ({
            operand?: AST;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("operator" in data && data.operator != undefined) {
                    this.operator = data.operator;
                }
                if ("left" in data && data.left != undefined) {
                    this.left = data.left;
                }
                if ("right" in data && data.right != undefined) {
                    this.right = data.right;
                }
                if ("arguments" in data && data.arguments != undefined) {
                    this.arguments = data.arguments;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("refType" in data && data.refType != undefined) {
                    this.refType = data.refType;
                }
                if ("key" in data && data.key != undefined) {
                    this.key = data.key;
                }
                if ("operand" in data && data.operand != undefined) {
                    this.operand = data.operand;
                }
                if ("number_value" in data && data.number_value != undefined) {
                    this.number_value = data.number_value;
                }
                if ("text_value" in data && data.text_value != undefined) {
                    this.text_value = data.text_value;
                }
                if ("logical_value" in data && data.logical_value != undefined) {
                    this.logical_value = data.logical_value;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, AstType.AST_UNKNOWN) as AstType;
        }
        set type(value: AstType) {
            pb_1.Message.setField(this, 1, value);
        }
        get operator() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set operator(value: string) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
        }
        get has_operator() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get left() {
            return pb_1.Message.getWrapperField(this, AST, 3) as AST;
        }
        set left(value: AST) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[2], value);
        }
        get has_left() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get right() {
            return pb_1.Message.getWrapperField(this, AST, 4) as AST;
        }
        set right(value: AST) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[3], value);
        }
        get has_right() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get arguments() {
            return pb_1.Message.getRepeatedWrapperField(this, AST, 5) as AST[];
        }
        set arguments(value: AST[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setOneofField(this, 6, this.#one_of_decls[4], value);
        }
        get has_name() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get refType() {
            return pb_1.Message.getFieldWithDefault(this, 7, RefType.REF_UNKNOWN) as RefType;
        }
        set refType(value: RefType) {
            pb_1.Message.setOneofField(this, 7, this.#one_of_decls[5], value);
        }
        get has_refType() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get key() {
            return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
        }
        set key(value: string) {
            pb_1.Message.setOneofField(this, 8, this.#one_of_decls[6], value);
        }
        get has_key() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get operand() {
            return pb_1.Message.getWrapperField(this, AST, 9) as AST;
        }
        set operand(value: AST) {
            pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[7], value);
        }
        get has_operand() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get number_value() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set number_value(value: number) {
            pb_1.Message.setOneofField(this, 10, this.#one_of_decls[0], value);
        }
        get has_number_value() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get text_value() {
            return pb_1.Message.getFieldWithDefault(this, 11, "") as string;
        }
        set text_value(value: string) {
            pb_1.Message.setOneofField(this, 11, this.#one_of_decls[0], value);
        }
        get has_text_value() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get logical_value() {
            return pb_1.Message.getFieldWithDefault(this, 12, false) as boolean;
        }
        set logical_value(value: boolean) {
            pb_1.Message.setOneofField(this, 12, this.#one_of_decls[0], value);
        }
        get has_logical_value() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get value() {
            const cases: {
                [index: number]: "none" | "number_value" | "text_value" | "logical_value";
            } = {
                0: "none",
                10: "number_value",
                11: "text_value",
                12: "logical_value"
            };
            return cases[pb_1.Message.computeOneofCase(this, [10, 11, 12])];
        }
        get _operator() {
            const cases: {
                [index: number]: "none" | "operator";
            } = {
                0: "none",
                2: "operator"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        get _left() {
            const cases: {
                [index: number]: "none" | "left";
            } = {
                0: "none",
                3: "left"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3])];
        }
        get _right() {
            const cases: {
                [index: number]: "none" | "right";
            } = {
                0: "none",
                4: "right"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        get _name() {
            const cases: {
                [index: number]: "none" | "name";
            } = {
                0: "none",
                6: "name"
            };
            return cases[pb_1.Message.computeOneofCase(this, [6])];
        }
        get _refType() {
            const cases: {
                [index: number]: "none" | "refType";
            } = {
                0: "none",
                7: "refType"
            };
            return cases[pb_1.Message.computeOneofCase(this, [7])];
        }
        get _key() {
            const cases: {
                [index: number]: "none" | "key";
            } = {
                0: "none",
                8: "key"
            };
            return cases[pb_1.Message.computeOneofCase(this, [8])];
        }
        get _operand() {
            const cases: {
                [index: number]: "none" | "operand";
            } = {
                0: "none",
                9: "operand"
            };
            return cases[pb_1.Message.computeOneofCase(this, [9])];
        }
        static fromObject(data: {
            type?: AstType;
            operator?: string;
            left?: ReturnType<typeof AST.prototype.toObject>;
            right?: ReturnType<typeof AST.prototype.toObject>;
            arguments?: ReturnType<typeof AST.prototype.toObject>[];
            name?: string;
            refType?: RefType;
            key?: string;
            operand?: ReturnType<typeof AST.prototype.toObject>;
            number_value?: number;
            text_value?: string;
            logical_value?: boolean;
        }): AST {
            const message = new AST({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.operator != null) {
                message.operator = data.operator;
            }
            if (data.left != null) {
                message.left = AST.fromObject(data.left);
            }
            if (data.right != null) {
                message.right = AST.fromObject(data.right);
            }
            if (data.arguments != null) {
                message.arguments = data.arguments.map(item => AST.fromObject(item));
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.refType != null) {
                message.refType = data.refType;
            }
            if (data.key != null) {
                message.key = data.key;
            }
            if (data.operand != null) {
                message.operand = AST.fromObject(data.operand);
            }
            if (data.number_value != null) {
                message.number_value = data.number_value;
            }
            if (data.text_value != null) {
                message.text_value = data.text_value;
            }
            if (data.logical_value != null) {
                message.logical_value = data.logical_value;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: AstType;
                operator?: string;
                left?: ReturnType<typeof AST.prototype.toObject>;
                right?: ReturnType<typeof AST.prototype.toObject>;
                arguments?: ReturnType<typeof AST.prototype.toObject>[];
                name?: string;
                refType?: RefType;
                key?: string;
                operand?: ReturnType<typeof AST.prototype.toObject>;
                number_value?: number;
                text_value?: string;
                logical_value?: boolean;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.operator != null) {
                data.operator = this.operator;
            }
            if (this.left != null) {
                data.left = this.left.toObject();
            }
            if (this.right != null) {
                data.right = this.right.toObject();
            }
            if (this.arguments != null) {
                data.arguments = this.arguments.map((item: AST) => item.toObject());
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.refType != null) {
                data.refType = this.refType;
            }
            if (this.key != null) {
                data.key = this.key;
            }
            if (this.operand != null) {
                data.operand = this.operand.toObject();
            }
            if (this.number_value != null) {
                data.number_value = this.number_value;
            }
            if (this.text_value != null) {
                data.text_value = this.text_value;
            }
            if (this.logical_value != null) {
                data.logical_value = this.logical_value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != AstType.AST_UNKNOWN)
                writer.writeEnum(1, this.type);
            if (this.has_operator)
                writer.writeString(2, this.operator);
            if (this.has_left)
                writer.writeMessage(3, this.left, () => this.left.serialize(writer));
            if (this.has_right)
                writer.writeMessage(4, this.right, () => this.right.serialize(writer));
            if (this.arguments.length)
                writer.writeRepeatedMessage(5, this.arguments, (item: AST) => item.serialize(writer));
            if (this.has_name)
                writer.writeString(6, this.name);
            if (this.has_refType)
                writer.writeEnum(7, this.refType);
            if (this.has_key)
                writer.writeString(8, this.key);
            if (this.has_operand)
                writer.writeMessage(9, this.operand, () => this.operand.serialize(writer));
            if (this.has_number_value)
                writer.writeFloat(10, this.number_value);
            if (this.has_text_value)
                writer.writeString(11, this.text_value);
            if (this.has_logical_value)
                writer.writeBool(12, this.logical_value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AST {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AST();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.operator = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.left, () => message.left = AST.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.right, () => message.right = AST.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.arguments, () => pb_1.Message.addToRepeatedWrapperField(message, 5, AST.deserialize(reader), AST));
                        break;
                    case 6:
                        message.name = reader.readString();
                        break;
                    case 7:
                        message.refType = reader.readEnum();
                        break;
                    case 8:
                        message.key = reader.readString();
                        break;
                    case 9:
                        reader.readMessage(message.operand, () => message.operand = AST.deserialize(reader));
                        break;
                    case 10:
                        message.number_value = reader.readFloat();
                        break;
                    case 11:
                        message.text_value = reader.readString();
                        break;
                    case 12:
                        message.logical_value = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AST {
            return AST.deserialize(bytes);
        }
    }
    export class Tokens extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tokens?: Tokens.Token[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tokens" in data && data.tokens != undefined) {
                    this.tokens = data.tokens;
                }
            }
        }
        get tokens() {
            return pb_1.Message.getRepeatedWrapperField(this, Tokens.Token, 1) as Tokens.Token[];
        }
        set tokens(value: Tokens.Token[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            tokens?: ReturnType<typeof Tokens.Token.prototype.toObject>[];
        }): Tokens {
            const message = new Tokens({});
            if (data.tokens != null) {
                message.tokens = data.tokens.map(item => Tokens.Token.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                tokens?: ReturnType<typeof Tokens.Token.prototype.toObject>[];
            } = {};
            if (this.tokens != null) {
                data.tokens = this.tokens.map((item: Tokens.Token) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tokens.length)
                writer.writeRepeatedMessage(1, this.tokens, (item: Tokens.Token) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tokens {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tokens();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.tokens, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Tokens.Token.deserialize(reader), Tokens.Token));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Tokens {
            return Tokens.deserialize(bytes);
        }
    }
    export namespace Tokens {
        export class Token extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                value?: string;
                type?: string;
                subtype?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("subtype" in data && data.subtype != undefined) {
                        this.subtype = data.subtype;
                    }
                }
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set value(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set type(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get subtype() {
                return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
            }
            set subtype(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                value?: string;
                type?: string;
                subtype?: string;
            }): Token {
                const message = new Token({});
                if (data.value != null) {
                    message.value = data.value;
                }
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.subtype != null) {
                    message.subtype = data.subtype;
                }
                return message;
            }
            toObject() {
                const data: {
                    value?: string;
                    type?: string;
                    subtype?: string;
                } = {};
                if (this.value != null) {
                    data.value = this.value;
                }
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.subtype != null) {
                    data.subtype = this.subtype;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.value.length)
                    writer.writeString(1, this.value);
                if (this.type.length)
                    writer.writeString(2, this.type);
                if (this.subtype.length)
                    writer.writeString(3, this.subtype);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Token {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Token();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.value = reader.readString();
                            break;
                        case 2:
                            message.type = reader.readString();
                            break;
                        case 3:
                            message.subtype = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Token {
                return Token.deserialize(bytes);
            }
        }
    }
}
