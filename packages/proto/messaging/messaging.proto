// Messaging Protocol Definitions
//
// This file defines the protobuf messages and services for the distributed
// typechecking and validation system. It provides the contract between
// message publishers and consumers in the ETL pipeline, ensuring reliable
// message processing and proper data serialization across worker nodes.
//
// The messaging system supports two main types of operations:
// 1. Schema Management: Creating, updating, and removing schema definitions
// 2. File Validation: Processing file validation requests against schemas
//
// All messages use hex-encoded binary data for safe transmission through
// JSON serialization, and include comprehensive metadata for processing
// context and priority management.
//
// Note: Some parameters from the original Python schemas have been omitted
// in this protobuf definition as they are no longer required for the
// simplified messaging architecture.

syntax = "proto3";

import "database/utils.proto";
import "messaging/validation.proto";
import "messaging/schemas.proto";
import "messaging/dtypes.proto";

package messaging;

// MessagingService defines RPC methods for handling distributed message processing
// in the typechecking system. This service provides streaming endpoints for both
// schema management and file validation operations across worker nodes.
//
// The service enables reliable message delivery between producers and consumers
// in the distributed validation system, ensuring proper data serialization
// and consistent message structure.
service MessagingService {
    // GetMessagingParams retrieves RabbitMQ connection parameters and configuration
    // Used by workers and services to obtain the necessary connection details for message broker setup
    rpc GetMessagingParams(GetMessagingParamsRequest) returns (GetMessagingParamsResponse) {}

    // GetRoutingKeySchemas retrieves the routing key used for schema management messages
    // Used by producers to determine the correct routing key when publishing schema operations to the message broker
    rpc GetRoutingKeySchemas(GetRoutingKeySchemasRequest) returns (RoutingKey);
    
    // GetRoutingKeyValidations retrieves the routing key used for validation request messages
    // Used by producers to determine the correct routing key when publishing validation requests to the message broker
    rpc GetRoutingKeyValidations(GetRoutingKeyValidationsRequest) returns (RoutingKey);

    // ReceiveSchemaMessage streams schema update messages to workers
    // Used for creating, updating, or removing schema definitions in the schema registry
    rpc ReceiveSchemaMessage(SchemaMessageRequest) returns (stream SchemaMessageResponse) {}
    
    // ReceiveValidationMessage streams validation request messages to workers
    // Used for processing file validation requests against specified schemas
    rpc ReceiveValidationMessage(ValidationMessageRequest) returns (stream ValidationMessageResponse) {}
}

// Request message for retrieving schema routing key information
// Currently empty as no filtering or specific parameters are required
// for obtaining the standard schema routing key configuration
message GetRoutingKeySchemasRequest {}

// Request message for retrieving validation routing key information
// Currently empty as no filtering or specific parameters are required
// for obtaining the standard validation routing key configuration
message GetRoutingKeyValidationsRequest {}

// Routing key response message for message broker routing configuration
//
// Contains the routing key string used for directing messages to the appropriate
// queues in the RabbitMQ exchange. This routing key determines which workers
// will receive specific types of messages based on the exchange routing rules.
//
// Routing keys are essential for proper message distribution in the distributed
// system, ensuring that schema messages reach schema workers and validation
// messages reach validation workers.
message RoutingKey {
    string routing_key = 1; // The routing key string used for message routing (e.g., "schema.upload", "validation.sample")
}

// Request message for retrieving messaging configuration parameters
// Currently empty as no filtering or specific parameters are required
// for obtaining the standard RabbitMQ connection configuration
message GetMessagingParamsRequest {}

// Response message containing RabbitMQ connection parameters and configuration
//
// Provides all necessary information for establishing connections to the
// message broker, including authentication credentials, connection details,
// and exchange configuration. This information is essential for workers
// and services to properly connect to the messaging infrastructure.
//
// The response contains both connection parameters and exchange configuration
// to ensure consistent messaging setup across all system components.
//
// Example usage:
//   GetMessagingParamsResponse {
//     host: "localhost"
//     port: 5672
//     virtual_host: "/etl"
//     username: "worker_user"
//     password: "secure_password"
//     exchange: {
//       exchange: "validation_exchange"
//       type: "direct"
//       durable: true
//       queues: [...]
//     }
//   }
message GetMessagingParamsResponse {
    string host = 1;                    // RabbitMQ server hostname or IP address
    int32 port = 2;                     // RabbitMQ server port number (typically 5672)
    string virtual_host = 3;            // Virtual host name for logical separation of messaging environments
    string username = 4;                // Authentication username for broker connection
    string password = 5;                // Authentication password for broker connection
    dtypes.ExchangeInfo exchange = 6;   // Exchange configuration including queues and routing information
}

// Request message for schema operations (currently empty)
// Future versions may include filtering or subscription parameters
message SchemaMessageRequest {}

// Schema update message for creating or updating schema definitions
// 
// Represents a message sent to schema workers for managing schema definitions
// in the schema registry. Contains the schema definition and associated
// metadata for proper storage, indexing, and retrieval operations.
//
// Schema messages maintain the schema registry that validation workers
// use to validate incoming files against defined data structures.
//
// Example usage:
//   SchemaMessageResponse {
//     id: "550e8400-e29b-41d4-a716-446655440001"
//     schema: { schema: "https://json-schema.org/draft/2020-12/schema", type: "object", ... }
//     import_name: "person_schema"
//     raw: false
//     task: UPLOAD_SCHEMA
//     date: "2024-01-15T10:30:00.000Z"
//   }
message SchemaMessageResponse {
    string id = 1;  // Unique identifier (UUID) for tracking the schema update request
    utils.JsonSchema schema = 2; // JSON schema definition containing validation rules, field types, and constraints
    string import_name = 3; // Unique identifier for the schema used for storage and retrieval operations
    bool raw = 4; // Boolean flag indicating if the schema is raw (unprocessed) or processed
    schemas.SchemasTasks task = 5; // Task type: upload_schema or remove_schema
    string date = 6; // Date of the message creation in ISO format
    map<string, string> extra = 7; // Additional metadata or configuration parameters
}

// Request message for validation operations (currently empty)
// Future versions may include filtering or subscription parameters
message ValidationMessageRequest {}

// Validation request message for processing file validation requests
//
// Represents a message sent to validation workers for processing file
// validation requests against specified schemas. Contains all necessary
// information for workers to validate files and provide validation results.
//
// The file data is hex-encoded for safe transmission through the messaging
// system, ensuring binary data integrity across network boundaries.
// File metadata provides essential context about the uploaded file, including
// filename, content type, and size for optimal processing strategies.
//
// Example usage:
//   ValidationMessageResponse {
//     id: "550e8400-e29b-41d4-a716-446655440000"
//     task: SAMPLE_VALIDATION
//     file_data: "48656c6c6f2c576f726c64"  // "Hello,World" in hex
//     import_name: "user_schema"
//     metadata: {
//       filename: "users.csv"
//       content_type: "text/csv"
//       size: 12345
//     }
//     date: "2024-01-15T10:30:00.000Z"
//     extra: {"priority": "high", "batch_id": "batch_001"}
//   }
message ValidationMessageResponse {
    string id = 1;  // Unique identifier (UUID) for tracking the validation request
    validation.ValidationTasks task = 2;  // Task type: sample_validation for file validation operations
    string file_data = 3;  // Hexadecimal-encoded binary file content for validation
    string import_name = 4;  // Schema identifier to validate the file against
    validation.Metadata metadata = 5; // File metadata containing filename, content type, and size information
    string date = 6; // Date of the message creation in ISO format
    map<string, string> extra = 7; // Additional processing metadata such as priority, batch information, and other request-specific parameters
}
